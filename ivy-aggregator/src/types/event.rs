// Code generated by mk_event_rs.py
use borsh::BorshDeserialize;
use crate::pf;  // Import Pump.fun events and discriminators
use crate::types::public::Public;
use crate::types::source::Source;
use crate::types::signature::Signature;
use serde::ser::SerializeStruct;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use std::fmt;
use std::str::FromStr;

//
// === Helpers ===
//

pub fn deserialize_u64_from_string<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    struct StringOrNumber;

    impl<'de> de::Visitor<'de> for StringOrNumber {
        type Value = u64;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a string or unsigned integer")
        }

        fn visit_str<E: de::Error>(self, value: &str) -> Result<u64, E> {
            u64::from_str(value).map_err(de::Error::custom)
        }

        fn visit_string<E: de::Error>(self, value: String) -> Result<u64, E> {
            u64::from_str(&value).map_err(de::Error::custom)
        }

        fn visit_u64<E: de::Error>(self, value: u64) -> Result<u64, E> {
            Ok(value)
        }

        fn visit_i64<E: de::Error>(self, value: i64) -> Result<u64, E> {
            if value >= 0 {
                Ok(value as u64)
            } else {
                Err(E::custom(format!(
                    "expected non-negative number, got {}",
                    value
                )))
            }
        }
    }

    deserializer.deserialize_any(StringOrNumber)
}

pub fn serialize_u64_as_string<S>(value: &u64, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&value.to_string())
}

//
// === Trait + Mapping Macro ===
//

trait EventType: Sized + Serialize + for<'de> Deserialize<'de> {
    const NAME: &'static str;
    fn into_event_data(self) -> EventData;
}

macro_rules! impl_event_type {
    ($type:ty, $name:literal, $variant:ident) => {
        impl EventType for $type {
            const NAME: &'static str = $name;
            fn into_event_data(self) -> EventData {
                EventData::$variant(self)
            }
        }
    };
}

//
// === Enum for EventData ===
//

#[derive(Debug, Clone)]
pub enum EventData {
    GameCreate(GameCreateEvent),
    GameEdit(GameEditEvent),
    GameUpgrade(GameUpgradeEvent),
    GameSwap(GameSwapEvent),
    GameBurn(GameBurnEvent),
    GameDeposit(GameDepositEvent),
    GameWithdraw(GameWithdrawEvent),
    VaultDeposit(VaultDepositEvent),
    VaultWithdraw(VaultWithdrawEvent),
    SyncCreate(SyncCreateEvent),
    SyncSwap(SyncSwapEvent),
    Comment(CommentEvent),
    WorldCreate(WorldCreateEvent),
    WorldUpdate(WorldUpdateEvent),
    WorldSwap(WorldSwapEvent),
    WorldVesting(WorldVestingEvent),
    PfTrade(pf::PfTradeEvent),
    PfMigration(pf::PfMigrationEvent),
    PaBuy(pf::PaBuyEvent),
    PaSell(pf::PaSellEvent),
    SolPrice(SolPriceEvent),
}

impl EventData {
    pub fn from_bytes(data: &[u8]) -> Result<Option<Self>, String> {
        if data.len() < 8 {
            return Err("Data too short for discriminator".to_string());
        }

        let discriminator_bytes = &data[0..8];
        let discriminator = u64::from_le_bytes(
            discriminator_bytes.try_into()
                .map_err(|_| "Failed to convert discriminator bytes to array")?
        );
        let mut event_data = &data[8..];

        match discriminator {
            0xb9d412f7d15f4b3c => {
                let event = GameCreateEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameCreateEvent: {}", e))?;
                Ok(Some(EventData::GameCreate(event)))
            }
            0xf0ded0ff3776f1e1 => {
                let event = GameEditEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameEditEvent: {}", e))?;
                Ok(Some(EventData::GameEdit(event)))
            }
            0x7393bd91715e4054 => {
                let event = GameUpgradeEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameUpgradeEvent: {}", e))?;
                Ok(Some(EventData::GameUpgrade(event)))
            }
            0x5772818798527af3 => {
                let event = GameSwapEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameSwapEvent: {}", e))?;
                Ok(Some(EventData::GameSwap(event)))
            }
            0x2829c52d51c0a753 => {
                let event = GameBurnEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameBurnEvent: {}", e))?;
                Ok(Some(EventData::GameBurn(event)))
            }
            0xd1626ad453f9c13c => {
                let event = GameDepositEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameDepositEvent: {}", e))?;
                Ok(Some(EventData::GameDeposit(event)))
            }
            0xbb1188a853869ff6 => {
                let event = GameWithdrawEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize GameWithdrawEvent: {}", e))?;
                Ok(Some(EventData::GameWithdraw(event)))
            }
            0xd5661c0b15188928 => {
                let event = VaultDepositEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize VaultDepositEvent: {}", e))?;
                Ok(Some(EventData::VaultDeposit(event)))
            }
            0xa4c1f6dae1bbb260 => {
                let event = VaultWithdrawEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize VaultWithdrawEvent: {}", e))?;
                Ok(Some(EventData::VaultWithdraw(event)))
            }
            0x6b6c1f15defe797f => {
                let event = SyncCreateEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize SyncCreateEvent: {}", e))?;
                Ok(Some(EventData::SyncCreate(event)))
            }
            0x61f7837aceb6bb53 => {
                let event = SyncSwapEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize SyncSwapEvent: {}", e))?;
                Ok(Some(EventData::SyncSwap(event)))
            }
            0x2d4150b25ba4e2b0 => {
                let event = CommentEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize CommentEvent: {}", e))?;
                Ok(Some(EventData::Comment(event)))
            }
            0x236d8df4463cb849 => {
                let event = WorldCreateEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize WorldCreateEvent: {}", e))?;
                Ok(Some(EventData::WorldCreate(event)))
            }
            0x49166e011f4d3444 => {
                let event = WorldUpdateEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize WorldUpdateEvent: {}", e))?;
                Ok(Some(EventData::WorldUpdate(event)))
            }
            0x774452a7872e259e => {
                let event = WorldSwapEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize WorldSwapEvent: {}", e))?;
                Ok(Some(EventData::WorldSwap(event)))
            }
            0x23d7eb52cbccae12 => {
                let event = WorldVestingEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize WorldVestingEvent: {}", e))?;
                Ok(Some(EventData::WorldVesting(event)))
            }
            pf::PF_TRADE_EVENT_TAG => {
                let event = pf::PfTradeEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize PfTradeEvent: {}", e))?;
                return Ok(Some(EventData::PfTrade(event)));
            }
            pf::PF_MIGRATE_EVENT_TAG => {
                let event = pf::PfMigrationEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize PfMigrationEvent: {}", e))?;
                return Ok(Some(EventData::PfMigration(event)));
            }
            pf::PA_BUY_EVENT_TAG => {
                let event = pf::PaBuyEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize PaBuyEvent: {}", e))?;
                return Ok(Some(EventData::PaBuy(event)));
            }
            pf::PA_SELL_EVENT_TAG => {
                let event = pf::PaSellEvent::deserialize_reader(&mut event_data)
                    .map_err(|e| format!("Failed to deserialize PaSellEvent: {}", e))?;
                return Ok(Some(EventData::PaSell(event)));
            }
            _ => {
                return Ok(None);
            }
        }
    }

    pub fn get_source(&self) -> Source {
        match self {
            EventData::GameCreate(_) => Source::Ivy,
            EventData::GameEdit(_) => Source::Ivy,
            EventData::GameUpgrade(_) => Source::Ivy,
            EventData::GameSwap(_) => Source::Ivy,
            EventData::GameBurn(_) => Source::Ivy,
            EventData::GameDeposit(_) => Source::Ivy,
            EventData::GameWithdraw(_) => Source::Ivy,
            EventData::VaultDeposit(_) => Source::Ivy,
            EventData::VaultWithdraw(_) => Source::Ivy,
            EventData::SyncCreate(_) => Source::Ivy,
            EventData::SyncSwap(_) => Source::Ivy,
            EventData::Comment(_) => Source::Ivy,
            EventData::WorldCreate(_) => Source::Ivy,
            EventData::WorldUpdate(_) => Source::Ivy,
            EventData::WorldSwap(_) => Source::Ivy,
            EventData::WorldVesting(_) => Source::Ivy,
            EventData::PfTrade(..) => Source::Pf,
            EventData::PfMigration(..) => Source::Pf,
            EventData::PaBuy(..) => Source::Pa,
            EventData::PaSell(..) => Source::Pa,
            EventData::SolPrice(_) => Source::Fx,
        }
    }
}

//
// === Event Struct ===
//

#[derive(Debug, Clone)]
pub struct Event {
    pub data: EventData,
    pub signature: Signature,
    pub timestamp: u64,
}

//
// === Event Structs ===
//

// Custom event for SOL price updates (not from blockchain)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SolPriceEvent {
    pub price: f64,
}
impl_event_type!(SolPriceEvent, "solPriceEvent", SolPrice);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameCreateEvent {
    pub game: Public,
    pub mint: Public,
    #[serde(rename = "swapAlt")]
    pub swap_alt: Public,
    #[serde(rename = "ivyBalance")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_balance: u64,
    #[serde(rename = "gameBalance")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub game_balance: u64,
    pub name: String,
    pub symbol: String,
}
impl_event_type!(GameCreateEvent, "gameCreateEvent", GameCreate);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameEditEvent {
    pub game: Public,
    pub owner: Public,
    #[serde(rename = "withdrawAuthority")]
    pub withdraw_authority: Public,
    #[serde(rename = "gameUrl")]
    pub game_url: String,
    #[serde(rename = "shortDesc")]
    pub short_desc: String,
    #[serde(rename = "metadataUrl")]
    pub metadata_url: String,
    #[serde(rename = "iconUrl")]
    pub icon_url: String,
}
impl_event_type!(GameEditEvent, "gameEditEvent", GameEdit);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameUpgradeEvent {
    pub game: Public,
    #[serde(rename = "shortDesc")]
    pub short_desc: String,
}
impl_event_type!(GameUpgradeEvent, "gameUpgradeEvent", GameUpgrade);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameSwapEvent {
    pub game: Public,
    pub user: Public,
    #[serde(rename = "ivyBalance")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_balance: u64,
    #[serde(rename = "gameBalance")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub game_balance: u64,
    #[serde(rename = "ivyAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_amount: u64,
    #[serde(rename = "gameAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub game_amount: u64,
    #[serde(rename = "isBuy")]
    pub is_buy: bool,
}
impl_event_type!(GameSwapEvent, "gameSwapEvent", GameSwap);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameBurnEvent {
    pub game: Public,
    pub id: [u8; 32],
}
impl_event_type!(GameBurnEvent, "gameBurnEvent", GameBurn);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameDepositEvent {
    pub game: Public,
    pub id: [u8; 32],
}
impl_event_type!(GameDepositEvent, "gameDepositEvent", GameDeposit);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct GameWithdrawEvent {
    pub game: Public,
    pub id: [u8; 32],
    #[serde(rename = "withdrawAuthority")]
    pub withdraw_authority: Public,
}
impl_event_type!(GameWithdrawEvent, "gameWithdrawEvent", GameWithdraw);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct VaultDepositEvent {
    pub vault: Public,
    pub id: [u8; 32],
}
impl_event_type!(VaultDepositEvent, "vaultDepositEvent", VaultDeposit);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct VaultWithdrawEvent {
    pub vault: Public,
    pub id: [u8; 32],
}
impl_event_type!(VaultWithdrawEvent, "vaultWithdrawEvent", VaultWithdraw);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct SyncCreateEvent {
    pub sync: Public,
    #[serde(rename = "pumpMint")]
    pub pump_mint: Public,
    pub name: String,
    pub symbol: String,
    #[serde(rename = "shortDesc")]
    pub short_desc: String,
    #[serde(rename = "metadataUrl")]
    pub metadata_url: String,
    #[serde(rename = "iconUrl")]
    pub icon_url: String,
    #[serde(rename = "gameUrl")]
    pub game_url: String,
}
impl_event_type!(SyncCreateEvent, "syncCreateEvent", SyncCreate);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct SyncSwapEvent {
    pub sync: Public,
    pub user: Public,
    #[serde(rename = "virtualSolReserves")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub virtual_sol_reserves: u64,
    #[serde(rename = "virtualTokenReserves")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub virtual_token_reserves: u64,
    #[serde(rename = "solAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub sol_amount: u64,
    #[serde(rename = "tokenAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub token_amount: u64,
    #[serde(rename = "isBuy")]
    pub is_buy: bool,
    #[serde(rename = "isPswap")]
    pub is_pswap: bool,
}
impl_event_type!(SyncSwapEvent, "syncSwapEvent", SyncSwap);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct CommentEvent {
    pub game: Public,
    pub user: Public,
    #[serde(rename = "commentIndex")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub comment_index: u64,
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub timestamp: u64,
    pub text: String,
}
impl_event_type!(CommentEvent, "commentEvent", Comment);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct WorldCreateEvent {
    #[serde(rename = "ivyCurveMax")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_curve_max: u64,
    #[serde(rename = "curveInputScaleNum")]
    pub curve_input_scale_num: u32,
    #[serde(rename = "curveInputScaleDen")]
    pub curve_input_scale_den: u32,
}
impl_event_type!(WorldCreateEvent, "worldCreateEvent", WorldCreate);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct WorldUpdateEvent {
    #[serde(rename = "ivyInitialLiquidity")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_initial_liquidity: u64,
    #[serde(rename = "gameInitialLiquidity")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub game_initial_liquidity: u64,
    #[serde(rename = "ivyFeeBps")]
    pub ivy_fee_bps: u8,
    #[serde(rename = "gameFeeBps")]
    pub game_fee_bps: u8,
}
impl_event_type!(WorldUpdateEvent, "worldUpdateEvent", WorldUpdate);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct WorldSwapEvent {
    pub user: Public,
    #[serde(rename = "usdcBalance")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub usdc_balance: u64,
    #[serde(rename = "ivySold")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_sold: u64,
    #[serde(rename = "usdcAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub usdc_amount: u64,
    #[serde(rename = "ivyAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_amount: u64,
    #[serde(rename = "isBuy")]
    pub is_buy: bool,
}
impl_event_type!(WorldSwapEvent, "worldSwapEvent", WorldSwap);

#[derive(BorshDeserialize, Debug, Clone, Serialize, Deserialize)]
pub struct WorldVestingEvent {
    #[serde(rename = "ivyAmount")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_amount: u64,
    #[serde(rename = "ivyVested")]
    #[serde(serialize_with = "serialize_u64_as_string")]
    #[serde(deserialize_with = "deserialize_u64_from_string")]
    pub ivy_vested: u64,
}
impl_event_type!(WorldVestingEvent, "worldVestingEvent", WorldVesting);

//
// === Event impl Serialize/Deserialize ===
//

impl Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let (name, data) = match &self.data {
            EventData::GameCreate(e) => (GameCreateEvent::NAME, serde_json::to_value(e)),
            EventData::GameEdit(e) => (GameEditEvent::NAME, serde_json::to_value(e)),
            EventData::GameUpgrade(e) => (GameUpgradeEvent::NAME, serde_json::to_value(e)),
            EventData::GameSwap(e) => (GameSwapEvent::NAME, serde_json::to_value(e)),
            EventData::GameBurn(e) => (GameBurnEvent::NAME, serde_json::to_value(e)),
            EventData::GameDeposit(e) => (GameDepositEvent::NAME, serde_json::to_value(e)),
            EventData::GameWithdraw(e) => (GameWithdrawEvent::NAME, serde_json::to_value(e)),
            EventData::VaultDeposit(e) => (VaultDepositEvent::NAME, serde_json::to_value(e)),
            EventData::VaultWithdraw(e) => (VaultWithdrawEvent::NAME, serde_json::to_value(e)),
            EventData::SyncCreate(e) => (SyncCreateEvent::NAME, serde_json::to_value(e)),
            EventData::SyncSwap(e) => (SyncSwapEvent::NAME, serde_json::to_value(e)),
            EventData::Comment(e) => (CommentEvent::NAME, serde_json::to_value(e)),
            EventData::WorldCreate(e) => (WorldCreateEvent::NAME, serde_json::to_value(e)),
            EventData::WorldUpdate(e) => (WorldUpdateEvent::NAME, serde_json::to_value(e)),
            EventData::WorldSwap(e) => (WorldSwapEvent::NAME, serde_json::to_value(e)),
            EventData::WorldVesting(e) => (WorldVestingEvent::NAME, serde_json::to_value(e)),
            EventData::PfTrade(e) => ("pfTradeEvent", serde_json::to_value(e)),
            EventData::PfMigration(e) => ("pfMigrationEvent", serde_json::to_value(e)),
            EventData::PaBuy(e) => ("paBuyEvent", serde_json::to_value(e)),
            EventData::PaSell(e) => ("paSellEvent", serde_json::to_value(e)),
            EventData::SolPrice(e) => (SolPriceEvent::NAME, serde_json::to_value(e)),
        };

        let data = data.map_err(serde::ser::Error::custom)?;

        let mut event = serializer.serialize_struct("Event", 4)?;
        event.serialize_field("name", &name)?;
        event.serialize_field("data", &data)?;
        event.serialize_field("signature", &self.signature)?;
        event.serialize_field("timestamp", &self.timestamp.to_string())?;
        event.end()
    }
}

impl<'de> Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct RawEvent {
            name: String,
            data: serde_json::Value,
            signature: Signature,
            #[serde(deserialize_with = "deserialize_u64_from_string")]
            timestamp: u64,
        }

        let raw_event = RawEvent::deserialize(deserializer)?;
        let data = deserialize_event_data(&raw_event.name, raw_event.data)?;

        Ok(Event {
            data,
            signature: raw_event.signature,
            timestamp: raw_event.timestamp,
        })
    }
}

fn deserialize_event_data<E: de::Error>(
    name: &str,
    data: serde_json::Value,
) -> Result<EventData, E> {
    if name == GameCreateEvent::NAME {
        return serde_json::from_value::<GameCreateEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameEditEvent::NAME {
        return serde_json::from_value::<GameEditEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameUpgradeEvent::NAME {
        return serde_json::from_value::<GameUpgradeEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameSwapEvent::NAME {
        return serde_json::from_value::<GameSwapEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameBurnEvent::NAME {
        return serde_json::from_value::<GameBurnEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameDepositEvent::NAME {
        return serde_json::from_value::<GameDepositEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == GameWithdrawEvent::NAME {
        return serde_json::from_value::<GameWithdrawEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == VaultDepositEvent::NAME {
        return serde_json::from_value::<VaultDepositEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == VaultWithdrawEvent::NAME {
        return serde_json::from_value::<VaultWithdrawEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == SyncCreateEvent::NAME {
        return serde_json::from_value::<SyncCreateEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == SyncSwapEvent::NAME {
        return serde_json::from_value::<SyncSwapEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == CommentEvent::NAME {
        return serde_json::from_value::<CommentEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == WorldCreateEvent::NAME {
        return serde_json::from_value::<WorldCreateEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == WorldUpdateEvent::NAME {
        return serde_json::from_value::<WorldUpdateEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == WorldSwapEvent::NAME {
        return serde_json::from_value::<WorldSwapEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == WorldVestingEvent::NAME {
        return serde_json::from_value::<WorldVestingEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }
    if name == "pfTradeEvent" {
        return serde_json::from_value::<pf::PfTradeEvent>(data)
            .map(|e| EventData::PfTrade(e))
            .map_err(E::custom);
    }
    if name == "pfMigrationEvent" {
        return serde_json::from_value::<pf::PfMigrationEvent>(data)
            .map(|e| EventData::PfMigration(e))
            .map_err(E::custom);
    }
    if name == "paBuyEvent" {
        return serde_json::from_value::<pf::PaBuyEvent>(data)
            .map(|e| EventData::PaBuy(e))
            .map_err(E::custom);
    }
    if name == "paSellEvent" {
        return serde_json::from_value::<pf::PaSellEvent>(data)
            .map(|e| EventData::PaSell(e))
            .map_err(E::custom);
    }
    if name == SolPriceEvent::NAME {
        return serde_json::from_value::<SolPriceEvent>(data)
            .map(|e| e.into_event_data())
            .map_err(E::custom);
    }

    Err(E::custom(format!("Unknown event type: {}", name)))
}

